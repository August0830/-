### 多项式计算器

#### 需求分析

能够在计算器关闭之前 读入 计算 存储多项式

读入：数据处理和存储单个多项式 多项式处理和多项式计算式处理

计算：主要模块：混合运算（加减乘） 求导 定积分 求逆 除法 求根

存储多项式 在需要时通过名字调用 或者采用查看功能

#### 数据结构

类：

​	计算器是一个类 成员有多项式 成员函数是多项式的多种运算

​	vector<Poly> polylist //只存储用户明确命名的多项式 计算式结果不存入

多项式结构体

​	用户定义名字（只能是英文，需要检查是否重复）+多项式数组



##### 数组

输入长度->便于确定数组长度//长度-1=最高项次数

```
多项式长度：3
请输入
2 0 3
实际：2x^2+0*x+3=2x^2+3
```

数组下标表示

| 数组下标==多项式次数 | 0    | 1    | 2    |
| -------------------- | ---- | ---- | ---- |
| 元素的值 多项式系数  | 3    | 0    | 2    |

##### 输入与输出

字符串型输入并 存入数组中 计算时转化改装成数字

```
5.70 在cout中 5.7`
2.0 自编小函数 用字符串处理 方法get`
```

查看：查看指定名称的多项式 或者查看现在计算器存储的所有多项式

#### 模块划分 

主函数

​	启动程序时创造一个计算器对象 对象内函数完成功能

​	循环不结束 不撤销对象 保存结果

输入+数字处理+输出

Calculator.h 

成员：多项式存储vector<Poly>

Calculator.cpp 具体功能实现  

​			包括多项式中缀转后缀表达式、计算多项式混合运算最终结果 输出结果 检查命名是否合法

Func.h

Func.cpp  加减乘 求导 定积分 求逆 除法 求根

计算模块

​	独立计算函数 在混合运算中调用

​		加减：下标相同的对应向系数相加减

​		乘：最大项系数是两个多项式最大项系数之积 新建一个数组来储存 二轮循环

​		求导： 新建一个数组长度n-1的数组 下标为n（n>=1) 的元素的值存到n-1下标

​		定积分： 类似上 新数组长度n+1 n存到n+1· 次数为-1IntePoly 分解出积分范围Range 计算函数值Value

​		取模 a[n]=d[n-m]*b[m]+r[p]  求d[n-m] r[p]

```
a的最高项系数=n;
ar[n]:for(int i=0;i<=n;++i) ar[i]=a[n-i];
b[m]做系数调换得到br[m]
brv[m]=br[m]的逆 利用求逆
dr[n-m]=ar[n]*birv[n-m]mode(x^n-m+1);
```

​		求逆

```
for(int k=0;k<len(a[];++k))//a[0]==0 不存在逆
{
	if(k==0)
		b[0]=1/a[0];
	b[k]=0;
	for(int i=0;i<=k-1;++k)
		re
}
```

​		求根

```
对最高项次数为n的多项式F 求导数F1//F1（x0)==0 则替换为10^-10(一个极小但是不为0的数)
{
    double x0,x1;
    x1=1e-10;
    do
    {
        x0=x1;
        if(x0==0)
            x0=1e-10;
        x1=x0-Value(F,x0)/Value(F1,x0);
    }while(Value(F,x1)<-1e-5 || Value(F,x1)>1E-5);
    return x1;
}
double Value(Poly F，double x0)//辅助函数
{//n为F的最高项次数
	double x1=0;
	for(int i=0;i<=n;++i)
		{
			double x=1;
			for(int j=0;j<i;++j)
				x=x0*x;//x^i
			x1=F[i]*x+x1;
		}
	return x1;
}
```

​	

多项式计算和检查: 用栈以及后缀表达式 一边计算一边检查

中缀表达式转成后缀 顺便检查 bool ToSuffix(string infix, string &suffix)

计算后缀表达式 Poly CalExpress(string suffix)

需要一系列判断表达式是否合法的函数 

​			**考虑利用栈来判断**

​	只有在运算中能判断 保证遇到符号的时候有足够的操作项能够使用 计算之后弹出栈顶作为结果 如果栈不空说明操作不够用 判断求导、判断定积分需要保留 检查括号内是否为空

​	开头结尾是否合法 bool HeadTail(string infix)

​	加法乘法后的符号是否合法 bool AfterPlusMul(string infix)

​	定积分本身是否合法 bool InteLegal(string infix)

​	求导符号是否合法 bool DerivLegal(string infix)

​	判断符号优先级a 小于等于 b bool Junior(a,b)

​	判断是否是多项式 截取字母部分和计算器已经存储的名称对比

```
bool ToSuffix(string infix, string &suffix，string namelist[])//考虑检查操作数和操作符个数不匹配的问题
{
	if(!HeadTail(infix) || !AfterPlusMul(infix) || !IntegralLegal(infix) || !DerivLegal(infix))
	return false;
	Stack<string> operator;
	for(int i=0;i<infix.len();++i)
	{
		对混入的奇怪符号进行检查
		if(该项为多项式名称)//考虑使用字符串查找定位 输入多项式名称数组？
			存入suffix；
		else if(定积分之外的符号)
		{
			if(是')')
            {
            	while(栈不空且取出的元素非‘（’)
            		op=operator.pop();
            	if(栈空且取出非左括号)
            		return false；
            }
            else 
            {
            	while(栈不为空 && 该符号优先级小于等于栈顶现有符号)
            		取出栈顶符号
            	if(非括号)
            		operator.push_back();
            }
		}
	}
	operator。pop()并存入suffix//栈空之后
}
Poly CalExpress(string suffix)
{
	Poly answ；
	new stack；//Poly型来存结果 读取suffix来指导行动
	for(int i=0;i<suffix.len();++i)
	{
		if(suffix[i]是多项式名称)
			stack.push_back()；
		else if(双目运算符)
		{
			弹出两个元素;
			转化成运算 ;
			运算结果入栈;
		}
		else if(单目运算符)// ! $[]
		{
			弹出一个元素
			运算
			结果入栈；
		}
	}
	answ=stack.pop();
	return answ;
}
```



新思路：按照运算顺序 暴力计算所有该项

附加功能：保留计算结果

#### 错误日志

1. 多模块文件编译时 需要分别将调用函数的cpp和实现函数的cpp生成 .o文件再i链接

   ![image-20200527182432983](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200527182432983.png)

2. 较长的代码比如tosuffix 写完后自己设计一个小样例逐步推一遍 可以帮助检查类似于下标增减之类与整体思路关系不大但是会影响代码执行结果的bug 有助于提高编程效率