#### 读懂原有代码：

​	从服务端接收到棋盘更新后对于对方木板、对方位置的状态存储已经完成--->下棋决策代替randomwalk

​	在决策中如果建立了新的变量 需要在restart中清空

#### 下棋思路：

​	

​	设置木板--防守；走棋---进攻 哪种方法是最优 判断走棋比判断放板容易 优势 走棋 劣势放板

​	优的标准：在本步走完以后 在本棋局状态下垂直走向对面底线 使得本方步数最大程度少于对方步数的走法走向对方底线步数最小 （权重？）（缺乏远见？？？）当前限定30步 超过就计算固定棋局下最小步数

​	

​	限定步数 双方互动 局部最优 最靠近底线 周围没有挡板

​	开局策略

​		Reed

​		Stiller 

​	放板比下棋难决策 可能性更多

​		标准：最大可能增加对方步数

​		先缩小放板的范围：对方过半（简单版）存在板与刚开局没有板有区别 

​		放板标准 寻找到的路径比本方少两步

​		eg：使对方走s型 规则提示：

​	估值：对方最短步数-我方最短步数

​	正值->占优-->走棋

​	复制-->劣势-->放板-->无法放板-->走棋



放板策略：

​	在对方最短路径上放板 使得阻碍对方最多 阻碍我方最少

下棋策略

​	最短路径下一步 避免重复上一步

找最短路径

​	直接目标前进未必为最优---->四个方向的可行的下一步都尝试一次

​	需要裁剪重复的路径

#### 函数实现：

 1. 当前情况下 走到底线需要的步数 int CurStep（棋局， Location）

    伪代码

    

    ```
    int StepCount(ChessBoard,Location)
    { //D 表示现有位置向下一格的坐标，DL 表示现有位置先向下再向右的位置坐标
    	Location nextStep[3]={D,L,R};//表示目前可选的三个方向 0对应D（向下一格的坐标）以此类推 
    	int Cnt[3]={};
    	new Stack；//建立一个栈
    	int stepcnt=0;
    	for (int i=0;i<3;++i)
    	{
    		nextstep=Step[i];
    		while(棋子未到底线 && Stack不空)
    		{
    			if(nextstep可以走向底线)//上或者下取决于初始位置
    			{
    				stepcnt++;
                    Stack.push_back();
    			}
    			else
    			{
    				now=Stack.pop();//从栈中取出一个位置来判断
    				Stack.pushback(CreatenNewstep(now));
    				//把now能产生的合法下一步压入栈中
    			}
    		}
    		if(!Stack)//无法走到底线
    		{
    			newstep=U//考虑原路返回
    			cnt=-1;
    		}
    		else
    			Cnt[i]=cnt;//存下对应下一步在当前棋局下走到底线需要的步数
    	}
    		ChooseLeastCnt();//选择最少的那一步
    }
    ```

    

​	2. 判断对方被堵死了吗 bool IsBlocked

​				方式1 板与非本方底线边界是否构成一个闭合回路将对手包围 是则违规

​				方式2  是否有路径 使得对方获胜 本方推演的函数再来一次

3. 禁止木板重叠但是允许交叉 bool IsBlockRight

  4. 设置木板的策略函数 BlockBar SetBlockBar（Location Chessboard）

  5. 放板和放棋子的选择和比较 Step Choose（）‘//需要调用以上函数

  6. //评估函数 Evaluatioin 向下推演四步（两个回合）

  7. alpha belta剪枝

     ​	推演中的变量和当前变量不能相互干扰 比如棋局板的状态和棋子的位置

     ​	推演中的变量应该在递归函数内部生成防止互相干扰

     ​	一个修改：把this-》block设为函数参数 以便兼容 shortest shortinsd setblock countpath 

  8. nextstep

     ​	接受棋局变化并储存起来

     ​	计算当前最短路径并评估

     ​	根据评估

     ​		放板

     ​		走棋

#### 如何调试：

​		通过修改原本randomwalk函数来改变step 可以手动输入

​		对战config client的和bin的 118.25.152.44

​		127.0.0.1 原 19330

​		回放是机器人视角

​		小模块如何调试？ eg：IsBlocked

​		QuoridorUI.exe log_xx_xx.csv  //打开UI所在目录 使用cmd java -jar server.jar -p 19330 

> QuoridorUI.exe log_20200429_190442_021.csv

log_20200428_222242_470.csv  经典局 诱导

对战ip http://quoridor.nnzxzb.cn/202005061603/log_19639.txt

端口：50001
单步超时：2000 毫秒
服务端参数：[-p, 50001, -n, 30, -r, 3, -d, -t, 2000]

九点

手动输入

```
	int mode;
    cout << "输入走步" << endl;
    cin >> mode;//0 防守放板 1进攻下棋
    while (mode != 1 && mode != 0)
    {
        cin >> mode;
    }
    if (mode == 1)
    {
        Location nextLoc;
        cin >> nextLoc.x >> nextLoc.y;
        step.myNewLoc = nextLoc;//randomWalk(newChange.myLoc, newChange.enemyLoc);
    }//手动输入
    else if(mode==0)
    {
        BlockBar block;
        cin >> block.start.x >> block.start.y >> block.stop.x >> block.stop.y;
        step.myNewBlockBar = block;
    }
```

#### 错误记录日志

​	使用vector 需要using namespace std && include <vector>

​	20200504更新了patch02其他文件 没有更新服务端

​	log_20200504_111821_089.csv 失败的T字 solution：规范化挡板

​	全局变量mylast enemylast 在局部计算最短路径的时候被更改导致主要路径偏差 shortinsd在setblocks中调用了

​	出现（10，x）这样的坐标 solution 失败的路径没有从记录中剔除

​	判断板时 把正在判断的板加入当前局面 之后删除避免干扰下一轮

​	生成优先向左和优先向右的路径时 需要重置标记用的visited数组

​	留意vector为空的情况 先判读保证不是空再读取其中元素

​	放板的时候要自己初始化到this->blocks中



#### 经验学习

广度优先找最短路径

把套路和灵活情况 套路用变量记录到哪一步了----策略模块化

逐步调试 优化策略函数 善用复盘 

我的局限：策略研究不够透彻 时间不够用 在小细节上花费太多时间